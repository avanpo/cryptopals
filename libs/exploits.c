#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "modes.h"
#include "oracles.h"
#include "utils.h"

unsigned char *get_static_key()
{
	static unsigned char static_key[16];

	static int init = 0;
	if (!init) {
		srand(0);
		fill_random_bytes(static_key, 16);
		init = 1;
	}
	return static_key;
}

char break_ciphertext_single_byte_xor(const unsigned char *ciphertext, size_t length, unsigned char *plaintext)
{
	unsigned char key;

	double high_score = 0.0;
	int i, j;
	for (i = 0; i < 256; ++i) {
		for (j = 0; j < length; ++j) {
			plaintext[j] = ciphertext[j] ^ i;
		}
		double score = score_english(plaintext, length);
		if (score > high_score) {
			high_score = score;
			key = i;
		}
	}

	for (j = 0; j < length; ++j) {
		plaintext[j] = ciphertext[j] ^ key;
	}
	return key;
}

int detect_repeating_block(unsigned char *ciphertext, size_t length, int block_length)
{
	int i, j = 1, k, count = 0;
	for (i = 0; i < j; i += block_length) {
		for (j = i + block_length; j < length; j += block_length) {
			for (k = 0; ciphertext[i + k] == ciphertext[j + k] && k < block_length; ++k) {
				if (k == block_length - 1) {
					count++;
				}
			}
		}
	}
	return count;
}

int detect_oracle_block_length(oracle_t oracle)
{
	unsigned char in[1024] = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
	unsigned char out[1024];

	int i, size, s;
	size = oracle(in, 1, out);

	for (i = 2; i <= 32; ++i) {
		s = oracle(in, i, out);
		if (s != size) {
			return s - size;
		}
	}
	return 0;
}

int detect_oracle_mode(oracle_t oracle, int block_length)
{
	unsigned char in[1024] = "YELLOW SUBMARINEYELLOW SUBMARINEYELLOW SUBMARINE";
	unsigned char out[1024];

	int length = oracle(in, 48, out);

	if (detect_repeating_block(out, length, block_length)) {
		return ECB;
	}

	return 0;
}

int detect_ECB_oracle_prefix_length(oracle_t oracle, int block_length)
{
	unsigned char in[1024] = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
	unsigned char out[1024];

	int i, length;
	for (i = 32; i < 48; ++i) {
		length = oracle(in, i, out);
		if (detect_repeating_block(out, length, block_length)) {
			return block_length - (i - 32);
		}
	}
	return 0;
}

int break_ciphertext_CBC_padding_oracle(const unsigned char *ciphertext,
		unsigned char *plaintext, size_t length, oracle_t oracle,
		const unsigned char *iv)
{
	unsigned char block_1[16], plaintext_2[16], input[32], input_iv[16];

	memcpy(input, ciphertext, 16);
	memcpy(input_iv, iv, 16);

	int i, j, b;
	for (i = 15; i >= 0; --i) {
		for (j = 15; j > i; --j) {
			input_iv[j] = iv[j] ^ plaintext_2[j] ^ (16 - i);
		}
		for (j = 0; j < 256; ++j) {
			input_iv[i] = iv[i] ^ j ^ (16 - i);
			if (oracle(input, 16, input_iv)) {
				plaintext_2[i] = j;
				break;
			}
		}
	}

	memcpy(input_iv, iv, 16);
	memcpy(plaintext, plaintext_2, 16);

	for (b = 0; b < (length / 16) - 1; ++b) {
		memcpy(block_1, ciphertext + (16 * b), 16);
		memcpy(input, ciphertext + (16 * b), 32);
		for (i = 15; i >= 0; --i) {
			for (j = 15; j > i; --j) {
				input[j] = block_1[j] ^ plaintext_2[j] ^ (16 - i);
			}
			for (j = 0; j < 256; ++j) {
				input[i] = block_1[i] ^ j ^ (16 - i);
				if (oracle(input, 32, input_iv)) {
					plaintext_2[i] = j;
					if ((j ^ (16 - i)) != 0) {
						break;
					}
				}
			}
		}
		memcpy(plaintext + 16 * (b + 1), plaintext_2, 16);
	}

	print_ascii(plaintext, length);
	return 0;
}
